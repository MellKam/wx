import "console" console {
  fn log(num: i32);
}

export fn start() {
  console::log(7);
}

module "memory" {
  fn copy(size: usize, source: usize, destination: usize);
}

impl X {
  fn hello()
}

struct Ref<T> {
  ptr: *mut T,
}

enum Alignment(usize) {
  Align1 = 1 >> 1,
  Align2 = 1 >> 2,
}

struct Layout {
  size: usize,
  align: Alignment,
}

struct BumpAllocator[a] {}

impl BumpAllocator[a] {
  fn allocate<T>(layout: Layout): Result<*const u8, AllocateError>;
}

struct String[a] {
  ptr: *[a]const u8,
  length: usize,
}

fn get_accessor(): String[static] { "id" };

fn get_string[a](allocator: *[a]mut BumpAllocator): *[a]const u8 {
  const str: String = "hello";
  const dest = allocator.alloc(Layout { size: str.length, align: Alignment::Align1 });
  memory::copy(str.length, str.ptr, dest);
  return String {  }
}

fn main() {
  const bump: BumpAllocator[block] = BumpAllocator::new(); 
  const x: String[static] = "hello world";

  block X: u32 {
    break X: 5;
  }

  let x: u32 = match (5): u32 {
    x if x > 5 => 0,
    _ => 1
  }
}


impl<T> *const <T> {
  fn deref(): T;
}
|
impl Point {
  fn add(self: *const Self, other: *const Point): Point {
    x: const = self*.x + other*.x;
    return Point::new(
      self*.x + other*.x,
      self*.y + other*.y,
    );
  }
} 

generic <T> lifetime [a] struct X {
  x: &[a] T
}

generic <T>
fn hello(a: T): u32 {

}

fn x(y: i32) {
  match y {
    0 -> block {

    },
    1 -> return 2,
    _ => return 4,
  };
}

block X {
  block Y: i32 {
    break X: 5;
    break 5;
    continue X;
  }
}

lifetime [a]
struct LinkedList<T> {
  head: *'a const T,
  tail: *'a const LinkedList<T>,
}

impl Into<i32, u32> for i32 {
  fn cast(self: i32): u32 {
    return self as u32;
  }
}

let a = block'a {
  block'b: i32 {
    break'a 5;
  }
};


if a { 5 } else { 6 }
block { 5 }

loop'a: i32 {
  loop'b: i32 {
    break'a 5;
  }
}

x: loop {
  break x: 5;
}

loop'x {
  break'x 5;
}

'a: loop {
  loop'b {
    break'a 5;
  }
}

for x in 0..10 {

}

loop {
  loop {
    break;
  }
}

loop {
  loop {
    continue;
  }
}

for'a x in 0..10 {
  for y in 0..10 {
    break'a 5;
  }
}

loop {
  break 5;
}

loop {
  loop {
    break 5;
  }
}

loop {
  loop {
    break;
  }
}

loop {
  loop {
    continue;
  }
}

let x = loop {
  loop {

  }
};

fn x() {
  let x = 5;
  _ = rl::startDrawing();
}

mut x = if true {
  5
} else {
  6
};

match x {
  x if x > 5 => let x = 5,
  _ => 8
};
