# Function definition
fn (a: i32, b: i32): i32 { ... }

# Function declaration
fn (a: i32, b: i32): i32;

# Block expression
{ ... }
block: i32 { ... }
block X { ... }
block X: i32 { ... }

# Match expression
match x {
  x if x > 5 => let x =5,
  _ => 8
}

# variable definition 
mut x: i64 = 5;
const y: i32 = 8;

impl Into<i32, u32> {
  fn cast(self: i32): u32 {
    
  } 
} 

const z = x / y.(u32);

never | int

fn start(): never {
  const x: i32 = match true {
    true => return 5, // never
    false => 5, // int
  }

  const x: never = match true {
    true => return 5, // never
    false => return 8, // never
  };

  match true {
    true => return 5, // never
    false => return 8, // never
  };

  return unit;

  loop {
    noop;
  };
}

fn fibonacci(n: i32): i32 {
  if n == 0 { 
    0
  } else {
    if n == 1 { 
      1 
    } else {
      fibonacci(n - 1) + fibonacci(n - 2)
    }
  }
}

fn fibonacci(n: i32): i32 {
  match n {
    0 -> 0,
    1 -> 1,
    _ -> fibonacci(n - 1) + fibonacci(n - 2),
  }
}

module core {
  public enum bool: i32 {
    false = 0,
    true = 1,
  }
}

export fn main(): bool {
  const x: bool = true

  return match x {
    true -> {}
    false -> {}
  }
}

fn main(): i32 {
  
}


const add = fn(a: i32, b: i32): i32 {
  a + b
}
const x = add(5, 5);

type Person = {
  name: i32,
  age: i32,
}

const person = Person {
  name: 5,
  age: 8,
}

global x: i32 = 0;


const x = if true { 5 as i32 } else { 5 }
const y = if true { 5 } else { 5 }

outer: block {
  loop: i64 {
    break :outer 5;
  }
}